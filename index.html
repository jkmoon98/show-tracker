<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ShowTracker - Your TV Show Diary</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+3:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-card: #21262d;
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --text-muted: #6e7681;
      --accent: #3fb950;
      --accent-hover: #2ea043;
      --accent-orange: #d29922;
      --border: rgba(48,54,61,0.5);
      --rating-star: #3fb950;
    }

    body {
      font-family: 'Source Sans 3', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      font-size: 15px;
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
    }

    #root {
      position: relative;
      z-index: 1;
      min-height: 100vh;
    }

    /* Header – minimal */
    .app-header {
      padding: 28px 24px 24px;
      border-bottom: 1px solid var(--border);
    }

    .app-title {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--text-primary);
    }

    .app-subtitle {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .container {
      max-width: 1280px;
      margin: 0 auto;
      padding: 24px 20px;
      position: relative;
    }

    /* Toolbar – compact */
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 28px;
      align-items: center;
    }

    .search-box {
      flex: 1;
      min-width: 220px;
      position: relative;
    }

    .search-input {
      width: 100%;
      padding: 8px 12px 8px 36px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 0.875rem;
      font-family: inherit;
      transition: border-color 0.15s;
    }

    .search-input::placeholder {
      color: var(--text-muted);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-muted);
    }

    .filter-select {
      padding: 8px 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 0.875rem;
      font-family: inherit;
      cursor: pointer;
    }

    .filter-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .btn-primary {
      padding: 8px 16px;
      background: var(--accent);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-size: 0.875rem;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: background 0.15s;
    }

    .btn-primary:hover {
      background: var(--accent-hover);
    }

    .btn-secondary {
      padding: 8px 16px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: border-color 0.15s, color 0.15s;
    }

    .btn-secondary:hover {
      border-color: var(--text-muted);
      color: var(--text-primary);
    }

    .view-toggle {
      display: flex;
      gap: 2px;
      background: var(--bg-secondary);
      padding: 2px;
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .view-toggle button {
      padding: 6px 12px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      font-size: 0.8125rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.15s;
    }

    .view-toggle button.active {
      background: var(--accent);
      color: #fff;
    }

    /* Poster grid – Letterboxd-style focus on posters */
    .poster-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 16px;
      margin-bottom: 32px;
    }

    .poster-card {
      position: relative;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .poster-card:hover {
      transform: translateY(-2px);
    }

    .poster-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 2/3;
      background: var(--bg-card);
      border-radius: 6px;
      overflow: hidden;
    }

    .poster-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .poster-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.75) 0%, transparent 50%);
      opacity: 0;
      transition: opacity 0.2s;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding: 10px;
    }

    .poster-card:hover .poster-overlay {
      opacity: 1;
    }

    .poster-rating {
      display: flex;
      gap: 2px;
      margin-bottom: 6px;
    }

    .show-title {
      font-size: 0.8125rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-top: 6px;
      line-height: 1.35;
      text-align: center;
    }

    /* List view – cleaner rows */
    .list-view {
      display: flex;
      flex-direction: column;
      gap: 0;
      margin-bottom: 32px;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    .list-item {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }

    .list-item:last-child {
      border-bottom: none;
    }

    .list-item:hover {
      background: var(--bg-card);
    }

    .list-poster {
      width: 44px;
      height: 66px;
      background: var(--bg-card);
      border-radius: 4px;
      overflow: hidden;
      flex-shrink: 0;
    }

    .list-poster img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .list-info { flex: 1; min-width: 0; }

    .list-title {
      font-size: 0.9375rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .list-meta {
      font-size: 0.8125rem;
      color: var(--text-muted);
    }

    .list-rating { display: flex; gap: 2px; }

    /* Status – small pills */
    .status-badge {
      display: inline-block;
      padding: 2px 8px;
      font-size: 0.6875rem;
      font-weight: 600;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .status-watching {
      background: var(--accent);
      color: #fff;
    }

    .status-completed {
      background: var(--accent-orange);
      color: #fff;
    }

    .status-planToWatch {
      background: #58a6ff;
      color: #fff;
    }

    .status-dropped {
      background: var(--text-muted);
      color: #fff;
    }

    /* Stats – slim inline feel */
    .stats-section {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      padding: 16px 0;
      margin-bottom: 28px;
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
    }

    .stat-item {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .stat-number {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--accent);
    }

    .stat-label {
      font-size: 0.8125rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    /* Modal – cleaner */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 28px;
      max-width: 520px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 20px;
      color: var(--text-primary);
    }

    .form-group { margin-bottom: 16px; }

    .form-label {
      display: block;
      font-size: 0.8125rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .form-input,
    .form-textarea,
    .form-select {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 0.9375rem;
      font-family: inherit;
      transition: border-color 0.15s;
    }

    .form-input:focus,
    .form-textarea:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .form-textarea {
      resize: vertical;
      min-height: 80px;
    }

    .star-rating-input { display: flex; gap: 6px; margin-top: 6px; }

    .star-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0;
      transition: transform 0.1s;
    }

    .star-btn:hover { transform: scale(1.1); }

    .star-icon { width: 24px; height: 24px; }

    .star-filled { fill: var(--rating-star); stroke: var(--rating-star); }

    .star-empty { fill: none; stroke: var(--text-muted); }

    .modal-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .modal-actions button { flex: 1; }

    /* TMDB results */
    .tmdb-results {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
      max-height: 320px;
      overflow-y: auto;
    }

    .tmdb-result {
      display: flex;
      gap: 12px;
      padding: 10px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: border-color 0.15s;
    }

    .tmdb-result:hover { border-color: var(--accent); }

    .tmdb-poster {
      width: 44px;
      height: 66px;
      background: var(--bg-card);
      border-radius: 4px;
      overflow: hidden;
      flex-shrink: 0;
    }

    .tmdb-poster img { width: 100%; height: 100%; object-fit: cover; }

    .tmdb-info { flex: 1; min-width: 0; }

    .tmdb-title {
      font-size: 0.9375rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .tmdb-meta { font-size: 0.8125rem; color: var(--text-muted); }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 48px 20px;
      color: var(--text-muted);
    }

    .empty-icon { margin-bottom: 12px; opacity: 0.5; }

    .empty-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .empty-text { font-size: 0.875rem; }

    /* Footer */
    .app-footer {
      text-align: center;
      padding: 28px 20px;
      color: var(--text-muted);
      font-size: 0.8125rem;
      border-top: 1px solid var(--border);
    }

    .app-footer a {
      color: var(--accent);
      text-decoration: none;
      font-weight: 500;
    }

    .app-footer a:hover { text-decoration: underline; }

    /* Auth */
    .auth-section {
      text-align: center;
      padding: 16px 20px;
      margin-bottom: 24px;
      border-bottom: 1px solid var(--border);
    }

    .user-info {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .loading {
      text-align: center;
      padding: 48px 20px;
      color: var(--text-muted);
      font-size: 0.9375rem;
    }

    /* Show detail modal – IMDb-style info */
    .detail-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .detail-modal-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      max-width: 640px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .detail-modal-body {
      display: flex;
      gap: 24px;
      padding: 24px;
    }

    .detail-poster {
      width: 160px;
      flex-shrink: 0;
      border-radius: 6px;
      overflow: hidden;
      background: var(--bg-card);
      aspect-ratio: 2/3;
    }

    .detail-poster img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .detail-info {
      flex: 1;
      min-width: 0;
    }

    .detail-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 6px;
    }

    .detail-meta {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .detail-meta span + span::before {
      content: ' · ';
      color: var(--text-muted);
    }

    .detail-rating-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .detail-user-rating {
      display: flex;
      gap: 2px;
    }

    .detail-overview {
      font-size: 0.9375rem;
      line-height: 1.6;
      color: var(--text-secondary);
      margin-bottom: 20px;
    }

    .detail-notes {
      font-size: 0.875rem;
      color: var(--text-muted);
      font-style: italic;
      margin-bottom: 20px;
    }

    .detail-cast-heading {
      font-size: 0.8125rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 8px;
    }

    .detail-cast-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 16px;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .detail-cast-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .detail-cast-item .name {
      color: var(--text-primary);
      font-weight: 500;
    }

    .detail-cast-item .character {
      color: var(--text-muted);
    }

    .detail-actions {
      display: flex;
      gap: 10px;
      margin-top: auto;
      padding: 16px 24px;
      border-top: 1px solid var(--border);
    }

    @media (max-width: 600px) {
      .detail-modal-body {
        flex-direction: column;
        padding: 20px;
      }
      .detail-poster {
        width: 120px;
        margin: 0 auto;
      }
    }

    @media (max-width: 768px) {
      .app-header { padding: 20px 16px; }
      .toolbar { flex-direction: column; margin-bottom: 20px; }
      .search-box { width: 100%; }
      .poster-grid {
        grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
        gap: 12px;
      }
      .modal-content { padding: 20px; }
      .stats-section { gap: 16px; padding: 12px 0; }
    }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }
    ::-webkit-scrollbar-thumb { background: var(--bg-card); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Load config from config.js (copy config.example.js → config.js and fill in). config.js is gitignored. -->
  <script src="config.js"></script>
  <script>
    window.FIREBASE_CONFIG = window.FIREBASE_CONFIG || {
      apiKey: '', authDomain: '', projectId: '', storageBucket: '', messagingSenderId: '', appId: ''
    };
    window.TMDB_API_KEY = window.TMDB_API_KEY || '';
  </script>
  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    // ============================================
    // FIREBASE CONFIGURATION
    // ============================================
    const firebaseConfig = window.FIREBASE_CONFIG;
    const isFileProtocol = window.location.protocol === 'file:';
    let auth = null;
    let db = null;
    let firebaseEnabled = false;

    if (firebaseConfig && firebaseConfig.apiKey) {
      try {
        firebase.initializeApp(firebaseConfig);
        auth = firebase.auth();
        db = firebase.firestore();
        firebaseEnabled = true;
      } catch (error) {
        console.error('Firebase initialization failed:', error);
      }
    }

    // ============================================
    // ICONS
    // ============================================

    const Star = ({ size = 24, filled = false }) => (
      <svg 
        className={`star-icon ${filled ? 'star-filled' : 'star-empty'}`}
        width={size} 
        height={size} 
        viewBox="0 0 24 24" 
        strokeWidth="2" 
        strokeLinecap="round" 
        strokeLinejoin="round"
      >
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
      </svg>
    );

    const Search = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
    );

    const Film = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect>
        <line x1="7" y1="2" x2="7" y2="22"></line>
        <line x1="17" y1="2" x2="17" y2="22"></line>
        <line x1="2" y1="12" x2="22" y2="12"></line>
        <line x1="2" y1="7" x2="7" y2="7"></line>
        <line x1="2" y1="17" x2="7" y2="17"></line>
        <line x1="17" y1="17" x2="22" y2="17"></line>
        <line x1="17" y1="7" x2="22" y2="7"></line>
      </svg>
    );

    const Plus = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
    );

    const X = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    );

    // ============================================
    // TMDB API (client-side; key from config.js – works on free Spark plan)
    // ============================================
    const TMDB_API_KEY = window.TMDB_API_KEY;
    const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
    const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';

    const searchTMDB = async (query) => {
      if (!query.trim() || !TMDB_API_KEY) return [];
      try {
        const response = await fetch(
          `${TMDB_BASE_URL}/search/tv?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}`
        );
        const data = await response.json();
        return data.results || [];
      } catch (error) {
        console.error('TMDB search error:', error);
        return [];
      }
    };

    const fetchTMDBDetails = async (tvId) => {
      if (!tvId || !TMDB_API_KEY) return null;
      try {
        const response = await fetch(
          `${TMDB_BASE_URL}/tv/${tvId}?api_key=${TMDB_API_KEY}`
        );
        if (!response.ok) return null;
        return await response.json();
      } catch (error) {
        console.error('TMDB details error:', error);
        return null;
      }
    };

    const fetchTMDBCredits = async (tvId) => {
      if (!tvId || !TMDB_API_KEY) return null;
      try {
        const response = await fetch(
          `${TMDB_BASE_URL}/tv/${tvId}/credits?api_key=${TMDB_API_KEY}`
        );
        if (!response.ok) return null;
        const data = await response.json();
        return data.cast || [];
      } catch (error) {
        console.error('TMDB credits error:', error);
        return [];
      }
    };

    // ============================================
    // STATUS CONFIG
    // ============================================

    const statusConfig = {
      watching: { label: 'Watching', color: '#3fb950', className: 'status-watching' },
      completed: { label: 'Completed', color: '#d29922', className: 'status-completed' },
      planToWatch: { label: 'Plan to Watch', color: '#58a6ff', className: 'status-planToWatch' },
      dropped: { label: 'Dropped', color: '#6e7681', className: 'status-dropped' }
    };

    // ============================================
    // GUEST MODE (localStorage when not signed in)
    // ============================================
    const GUEST_STORAGE_KEY = 'show-tracker-guest-shows';

    const loadGuestShows = () => {
      try {
        const raw = localStorage.getItem(GUEST_STORAGE_KEY);
        if (!raw) return [];
        const list = JSON.parse(raw);
        if (!Array.isArray(list)) return [];
        return list.map(show => {
          let posterUrl = show.posterUrl || '';
          if (!posterUrl && show.posterPath) posterUrl = `${TMDB_IMAGE_BASE}${show.posterPath}`;
          return { ...show, posterUrl };
        });
      } catch {
        return [];
      }
    };

    const saveGuestShows = (list) => {
      try {
        localStorage.setItem(GUEST_STORAGE_KEY, JSON.stringify(list));
      } catch (e) {
        console.error('Guest save failed:', e);
      }
    };

    // ============================================
    // MAIN APP
    // ============================================

    const TVShowTracker = () => {
      const [shows, setShows] = useState([]);
      const [user, setUser] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      const [searchQuery, setSearchQuery] = useState('');
      const [statusFilter, setStatusFilter] = useState('all');
      const [viewMode, setViewMode] = useState('grid');
      const [sortOption, setSortOption] = useState('titleAsc');
      const [isAddingShow, setIsAddingShow] = useState(false);
      const [editingShow, setEditingShow] = useState(null);
      const [viewingShow, setViewingShow] = useState(null);

      // Auth listener + guest load
      useEffect(() => {
        if (!firebaseEnabled) {
          setShows(loadGuestShows());
          setIsLoading(false);
          return;
        }

        const unsubscribe = auth.onAuthStateChanged((user) => {
          setUser(user);
          if (user) {
            loadShows(user.uid);
          } else {
            setShows(loadGuestShows());
            setIsLoading(false);
          }
        });

        return () => unsubscribe();
      }, []);

      // Expose console helper when app is mounted (run refreshCompletedSeasonsFromTMDB() in DevTools)
      useEffect(() => {
        window.refreshCompletedSeasonsFromTMDB = async function() {
          const user = auth?.currentUser;
          if (user) {
            const userRef = db.collection('users').doc(user.uid);
            const snap = await userRef.get();
            const data = snap.data() || {};
            const showsMap = data.shows || {};
            let updated = 0;
            for (const [id, show] of Object.entries(showsMap)) {
              if (show.status !== 'completed' || !show.tmdbId) continue;
              const details = await fetchTMDBDetails(show.tmdbId);
              if (details?.number_of_seasons == null) continue;
              showsMap[id] = { ...show, seasons: details.number_of_seasons, imdbRating: details.vote_average ?? show.imdbRating };
              updated++;
            }
            if (updated > 0) {
              await userRef.set({ shows: showsMap, lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
              console.log('Updated', updated, 'completed show(s). Refresh the page.');
            } else {
              console.log('No completed shows with TMDB ID found.');
            }
          } else {
            const list = loadGuestShows();
            let updated = 0;
            for (let i = 0; i < list.length; i++) {
              const show = list[i];
              if (show.status !== 'completed' || !show.tmdbId) continue;
              const details = await fetchTMDBDetails(show.tmdbId);
              if (details?.number_of_seasons == null) continue;
              list[i] = { ...show, seasons: details.number_of_seasons, imdbRating: details.vote_average ?? show.imdbRating };
              updated++;
            }
            if (updated > 0) {
              saveGuestShows(list);
              console.log('Updated', updated, 'completed show(s). Refresh the page.');
            } else {
              console.log('No completed shows with TMDB ID found.');
            }
          }
        };
        // Link shows that have no TMDB id: search by title, take first result, fill in tmdbId + details (fully automated, no throws)
        window.linkUnlinkedShowsToTMDB = async function() {
          const delay = (ms) => new Promise(r => setTimeout(r, ms));
          try {
            const user = auth?.currentUser;
            let showsMap = {};
            try {
              if (user) {
                const snap = await db.collection('users').doc(user.uid).get();
                const data = snap.data() || {};
                showsMap = data.shows || {};
              } else {
                const list = loadGuestShows();
                showsMap = Object.fromEntries((list || []).map(s => [String(s.id), { ...s }]));
              }
            } catch (e) {
              console.warn('Could not load shows:', e.message);
              return;
            }
            const needLink = Object.entries(showsMap).filter(([, s]) => s && !s.tmdbId && (s.title || '').trim());
            if (needLink.length === 0) {
              console.log('All shows already have a TMDB link.');
              return;
            }
            console.log('Linking', needLink.length, 'show(s) to TMDB...');
            let linked = 0;
            for (const [id, show] of needLink) {
              try {
                const title = (show.title || '').trim();
                if (!title) continue;
                const q = show.year ? `${title} ${show.year}` : title;
                const results = await searchTMDB(q);
                await delay(300);
                if (!results || !results.length) {
                  console.log('Skip (no result):', title);
                  continue;
                }
                const first = results[0];
                if (!first || first.id == null) continue;
                const details = await fetchTMDBDetails(first.id);
                await delay(300);
                const numSeasons = details && details.number_of_seasons != null ? details.number_of_seasons : '';
                const voteAvg = details && details.vote_average != null ? Number(details.vote_average) : 0;
                showsMap[id] = {
                  ...show,
                  title: first.name || title,
                  year: (first.first_air_date && first.first_air_date.substring(0, 4)) || show.year || '',
                  posterUrl: first.poster_path ? `${TMDB_IMAGE_BASE}${first.poster_path}` : (show.posterUrl || ''),
                  tmdbId: first.id,
                  seasons: numSeasons,
                  imdbRating: voteAvg
                };
                linked++;
                console.log('Linked:', title, '→', first.name || first.id);
              } catch (err) {
                console.warn('Skip', show.title, err.message);
              }
            }
            if (linked === 0) {
              console.log('No shows updated.');
              return;
            }
            try {
              if (user) {
                await db.collection('users').doc(user.uid).set(
                  { shows: showsMap, lastUpdated: firebase.firestore.FieldValue.serverTimestamp() },
                  { merge: true }
                );
              } else {
                const list = Object.keys(showsMap).sort((a, b) => Number(a) - Number(b)).map(k => ({ ...showsMap[k], id: k }));
                saveGuestShows(list);
              }
              console.log('Done. Updated', linked, 'show(s). Refresh the page.');
            } catch (e) {
              console.warn('Save failed:', e.message);
            }
          } catch (err) {
            console.warn('linkUnlinkedShowsToTMDB error:', err.message);
          }
        };

        return () => {
          delete window.refreshCompletedSeasonsFromTMDB;
          delete window.linkUnlinkedShowsToTMDB;
        };
      }, []);

      const loadShows = async (userId) => {
        setIsLoading(true);
        try {
          const userDoc = await db.collection('users').doc(userId).get();
          if (!userDoc.exists) {
            setShows([]);
            setIsLoading(false);
            return;
          }
          const data = userDoc.data() || {};
          const showsMap = data.shows || {};
          const loadedShows = Object.keys(showsMap).map(key => {
            const show = showsMap[key];
            let posterUrl = show.posterUrl || '';
            if (!posterUrl && show.posterPath) {
              posterUrl = `${TMDB_IMAGE_BASE}${show.posterPath}`;
            }
            return { id: key, ...show, posterUrl };
          });
          setShows(loadedShows);
        } catch (error) {
          console.error('Error loading shows:', error);
        } finally {
          setIsLoading(false);
        }
      };


      const signIn = async () => {
        if (!firebaseEnabled) return;
        try {
          const provider = new firebase.auth.GoogleAuthProvider();
          await auth.signInWithPopup(provider);
        } catch (error) {
          console.error('Sign in error:', error);
        }
      };

      const signOut = async () => {
        if (!firebaseEnabled || !auth) return;
        try {
          await auth.signOut();
        } catch (error) {
          console.error('Sign out error:', error);
        }
      };

      const saveShow = async (showData) => {
        if (!user) {
          // Guest mode: save to localStorage
          const list = loadGuestShows();
          const { id, ...rest } = showData;
          const payload = { ...rest };
          if (id !== null && id !== undefined && id !== '') {
            const idx = list.findIndex(s => String(s.id) === String(id));
            if (idx >= 0) {
              const next = [...list];
              next[idx] = { ...list[idx], ...payload, id: list[idx].id };
              saveGuestShows(next);
              setShows(next);
            } else {
              const next = [...list, { ...payload, id: list.length }];
              saveGuestShows(next);
              setShows(next);
            }
          } else {
            const next = [...list, { ...payload, id: list.length }];
            saveGuestShows(next);
            setShows(next);
          }
          setIsAddingShow(false);
          setEditingShow(null);
          return;
        }

        try {
          const userRef = db.collection('users').doc(user.uid);
          const userDoc = await userRef.get();
          const data = userDoc.data() || {};
          const showsMap = data.shows || {};
          
          if (showData.id) {
            showsMap[showData.id] = {
              ...showData,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            };
          } else {
            const nextId = Object.keys(showsMap).length;
            const { id, ...dataWithoutId } = showData;
            showsMap[nextId] = {
              ...dataWithoutId,
              createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
          }
          
          await userRef.set({
            shows: showsMap,
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
          
          await loadShows(user.uid);
          setIsAddingShow(false);
          setEditingShow(null);
        } catch (error) {
          console.error('Error saving show:', error);
        }
      };

      const deleteShow = async (showId) => {
        if (!confirm('Delete this show?')) return;
        if (!user) {
          const list = loadGuestShows().filter(s => String(s.id) !== String(showId));
          saveGuestShows(list);
          setShows(list);
          setEditingShow(null);
          return;
        }
        try {
          const userRef = db.collection('users').doc(user.uid);
          const updates = {
            [`shows.${showId}`]: firebase.firestore.FieldValue.delete(),
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
          };
          await userRef.update(updates);
          await loadShows(user.uid);
          setEditingShow(null);
        } catch (error) {
          console.error('Error deleting show:', error);
        }
      };

      // Filtered + Sorted shows
      const filteredShows = useMemo(() => {
        const filtered = shows.filter(show => {
          const matchesSearch = (show.title || '').toLowerCase().includes(searchQuery.toLowerCase());
          const matchesStatus = statusFilter === 'all' || show.status === statusFilter;
          return matchesSearch && matchesStatus;
        });

        const sorted = [...filtered];
        const safeNum = (v) => (typeof v === 'number' && !Number.isNaN(v) ? v : null);

        sorted.sort((a, b) => {
          const at = (a.title || '').toLowerCase();
          const bt = (b.title || '').toLowerCase();
          const ar = safeNum(a.imdbRating);
          const br = safeNum(b.imdbRating);

          switch (sortOption) {
            case 'titleDesc':
              return bt.localeCompare(at);
            case 'imdbAsc': {
              // missing ratings go last
              if (ar === null && br === null) return at.localeCompare(bt);
              if (ar === null) return 1;
              if (br === null) return -1;
              return ar - br || at.localeCompare(bt);
            }
            case 'imdbDesc': {
              if (ar === null && br === null) return at.localeCompare(bt);
              if (ar === null) return 1;
              if (br === null) return -1;
              return br - ar || at.localeCompare(bt);
            }
            case 'titleAsc':
            default:
              return at.localeCompare(bt);
          }
        });

        return sorted;
      }, [shows, searchQuery, statusFilter, sortOption]);

      // Stats
      const stats = useMemo(() => {
        return {
          total: shows.length,
          watching: shows.filter(s => s.status === 'watching').length,
          completed: shows.filter(s => s.status === 'completed').length,
          planToWatch: shows.filter(s => s.status === 'planToWatch').length,
          dropped: shows.filter(s => s.status === 'dropped').length
        };
      }, [shows]);

      return (
        <div>
          {/* Header */}
          <header className="app-header">
            <h1 className="app-title">ShowTracker</h1>
            <p className="app-subtitle">Your personal TV show diary</p>
          </header>

          <div className="container">
            {/* Auth Section */}
            {firebaseEnabled ? (
              <div className="auth-section">
                {user ? (
                  <div className="user-info">
                    <span>Signed in as {user.email}</span>
                    <button className="btn-secondary" onClick={signOut}>Sign Out</button>
                  </div>
                ) : isFileProtocol ? (
                  <div>
                    <p style={{ marginBottom: '12px', color: 'var(--text-secondary)' }}>
                      Sign-in only works over http. Run a local server:
                    </p>
                    <code style={{ display: 'block', padding: '12px', background: 'var(--bg-primary)', borderRadius: '4px', fontSize: '13px', marginBottom: '12px' }}>
                      npx serve .
                    </code>
                    <p style={{ color: 'var(--text-muted)', fontSize: '12px' }}>
                      Then open the URL it shows (e.g. http://localhost:3000)
                    </p>
                  </div>
                ) : (
                  <div>
                    <p style={{ marginBottom: '8px', color: 'var(--text-secondary)' }}>
                      Guest mode – your list is saved in this browser only.
                    </p>
                    <p style={{ marginBottom: '16px', color: 'var(--text-muted)', fontSize: '13px' }}>
                      Sign in to sync across devices
                    </p>
                    <button className="btn-primary" onClick={signIn}>Sign In with Google</button>
                  </div>
                )}
              </div>
            ) : (
              <div className="auth-section">
                <p style={{ color: 'var(--text-muted)', fontSize: '13px' }}>
                  Copy config.example.js to config.js and add your Firebase config to enable sync.
                </p>
              </div>
            )}

            {/* Toolbar */}
            <div className="toolbar">
              <div className="search-box">
                <Search className="search-icon" />
                <input
                  type="text"
                  className="search-input"
                  placeholder="Search shows..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                />
              </div>

              <select 
                className="filter-select"
                value={statusFilter}
                onChange={(e) => setStatusFilter(e.target.value)}
              >
                <option value="all">All Shows</option>
                {Object.entries(statusConfig).map(([key, config]) => (
                  <option key={key} value={key}>{config.label}</option>
                ))}
              </select>

              <select 
                className="filter-select"
                value={sortOption}
                onChange={(e) => setSortOption(e.target.value)}
              >
                <option value="titleAsc">Title (A–Z)</option>
                <option value="titleDesc">Title (Z–A)</option>
                <option value="imdbDesc">IMDb Rating (High → Low)</option>
                <option value="imdbAsc">IMDb Rating (Low → High)</option>
              </select>

              <div className="view-toggle">
                <button 
                  className={viewMode === 'grid' ? 'active' : ''}
                  onClick={() => setViewMode('grid')}
                >
                  Grid
                </button>
                <button 
                  className={viewMode === 'list' ? 'active' : ''}
                  onClick={() => setViewMode('list')}
                >
                  List
                </button>
              </div>

              <button 
                className="btn-primary" 
                onClick={() => setIsAddingShow(true)}
              >
                <Plus size={16} /> Add Show
              </button>
              {!user && firebaseEnabled && (
                <span style={{ fontSize: '12px', color: 'var(--text-muted)' }}>
                  Guest – saved in this browser
                </span>
              )}
            </div>

            {/* Content */}
            {isLoading ? (
              <div className="loading">Loading your shows...</div>
            ) : filteredShows.length === 0 ? (
              <div className="empty-state">
                <div className="empty-icon">
                  <Film size={64} />
                </div>
                <div className="empty-title">
                  {searchQuery ? 'No shows found' : 'No shows yet'}
                </div>
                <div className="empty-text">
                  {searchQuery ? 'Try a different search term' : 'Click "Add Show" to start tracking'}
                </div>
              </div>
            ) : viewMode === 'list' ? (
              <div className="list-view">
                {filteredShows.map(show => (
                  <div 
                    key={show.id} 
                    className="list-item"
                    onClick={() => setViewingShow(show)}
                  >
                    <div className="list-poster">
                      {show.posterUrl && (
                        <img src={show.posterUrl} alt={show.title} loading="lazy" />
                      )}
                    </div>
                    <div className="list-info">
                      <div className="list-title">{show.title}</div>
                      <div className="list-meta">
                        {show.year && <span>{show.year}</span>}
                        {show.seasons !== undefined && show.seasons !== '' && (
                          <>
                            {show.year && <span> • </span>}
                            <span>{show.seasons} season{Number(show.seasons) === 1 ? '' : 's'}</span>
                          </>
                        )}
                        {show.imdbRating ? (
                          <>
                            {(show.year || (show.seasons !== undefined && show.seasons !== '')) && <span> • </span>}
                            <span>IMDb {Number(show.imdbRating).toFixed(1)}</span>
                          </>
                        ) : null}
                        {(show.year || (show.seasons !== undefined && show.seasons !== '') || show.imdbRating) && <span> • </span>}
                        <span className={`status-badge ${statusConfig[show.status]?.className}`}>
                          {statusConfig[show.status]?.label}
                        </span>
                      </div>
                    </div>
                    {show.rating > 0 && (
                      <div className="list-rating">
                        {[...Array(5)].map((_, i) => (
                          <Star key={i} size={16} filled={i < show.rating} />
                        ))}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ) : (
              <div className="poster-grid">
                {filteredShows.map(show => (
                  <div 
                    key={show.id}
                    className="poster-card"
                    onClick={() => setViewingShow(show)}
                  >
                    <div className="poster-wrapper">
                      {show.posterUrl ? (
                        <img 
                          src={show.posterUrl} 
                          alt={show.title} 
                          className="poster-img"
                          loading="lazy"
                        />
                      ) : (
                        <div style={{ 
                          width: '100%', 
                          height: '100%', 
                          display: 'flex', 
                          alignItems: 'center', 
                          justifyContent: 'center',
                          color: 'var(--text-muted)'
                        }}>
                          <Film size={48} />
                        </div>
                      )}
                      <div className="poster-overlay">
                        {show.rating > 0 && (
                          <div className="poster-rating">
                            {[...Array(5)].map((_, i) => (
                              <Star key={i} size={14} filled={i < show.rating} />
                            ))}
                          </div>
                        )}
                        <span className={`status-badge ${statusConfig[show.status]?.className}`}>
                          {statusConfig[show.status]?.label}
                        </span>
                      </div>
                    </div>
                    <div className="show-title">{show.title}</div>
                  </div>
                ))}
              </div>
            )}

            {/* Stats */}
            {shows.length > 0 && (
              <div className="stats-section">
                <div className="stat-item">
                  <div className="stat-number">{stats.total}</div>
                  <div className="stat-label">Total</div>
                </div>
                <div className="stat-item">
                  <div className="stat-number" style={{ color: statusConfig.watching.color }}>
                    {stats.watching}
                  </div>
                  <div className="stat-label">Watching</div>
                </div>
                <div className="stat-item">
                  <div className="stat-number" style={{ color: statusConfig.completed.color }}>
                    {stats.completed}
                  </div>
                  <div className="stat-label">Completed</div>
                </div>
                <div className="stat-item">
                  <div className="stat-number" style={{ color: statusConfig.planToWatch.color }}>
                    {stats.planToWatch}
                  </div>
                  <div className="stat-label">Plan to Watch</div>
                </div>
                <div className="stat-item">
                  <div className="stat-number" style={{ color: statusConfig.dropped.color }}>
                    {stats.dropped}
                  </div>
                  <div className="stat-label">Dropped</div>
                </div>
              </div>
            )}
          </div>

          {/* Footer */}
          <footer className="app-footer">
            <p>This product uses the TMDB API but is not endorsed or certified by TMDB.</p>
            <p>
              <a href="https://www.themoviedb.org/" target="_blank" rel="noopener noreferrer">
                Powered by The Movie Database (TMDB)
              </a>
            </p>
          </footer>

          {/* Modals */}
          {isAddingShow && (
            <FormModal
              onSave={saveShow}
              onClose={() => setIsAddingShow(false)}
            />
          )}

          {viewingShow && (
            <ShowDetailModal
              show={viewingShow}
              onClose={() => setViewingShow(null)}
              onEdit={() => {
                setViewingShow(null);
                setEditingShow(viewingShow);
              }}
              onDelete={async (id) => {
                await deleteShow(id);
                setViewingShow(null);
              }}
            />
          )}

          {editingShow && (
            <FormModal
              show={editingShow}
              onSave={saveShow}
              onClose={() => setEditingShow(null)}
              onDelete={deleteShow}
            />
          )}
        </div>
      );
    };

    // ============================================
    // SHOW DETAIL MODAL (IMDb-style info)
    // ============================================

    const ShowDetailModal = ({ show, onClose, onEdit, onDelete }) => {
      const [tmdbDetails, setTmdbDetails] = useState(null);
      const [cast, setCast] = useState([]);
      const [loadingDetails, setLoadingDetails] = useState(!!show?.tmdbId);

      useEffect(() => {
        if (!show?.tmdbId) {
          setLoadingDetails(false);
          return;
        }
        let cancelled = false;
        Promise.all([
          fetchTMDBDetails(show.tmdbId),
          fetchTMDBCredits(show.tmdbId)
        ]).then(([details, castList]) => {
          if (!cancelled) {
            setTmdbDetails(details);
            setCast(Array.isArray(castList) ? castList.slice(0, 20) : []);
            setLoadingDetails(false);
          }
        }).catch(() => setLoadingDetails(false));
        return () => { cancelled = true; };
      }, [show?.tmdbId]);

      const overview = tmdbDetails?.overview || show.notes || null;

      return (
        <div className="detail-modal-overlay" onClick={onClose}>
          <div className="detail-modal-content" onClick={e => e.stopPropagation()}>
            <div className="detail-modal-body">
              <div className="detail-poster">
                {show.posterUrl ? (
                  <img src={show.posterUrl} alt={show.title} />
                ) : (
                  <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-muted)' }}>
                    <Film size={48} />
                  </div>
                )}
              </div>
              <div className="detail-info">
                <h2 className="detail-title">{show.title}</h2>
                {(show.year || (show.seasons !== undefined && show.seasons !== '') || tmdbDetails?.number_of_episodes != null) && (
                  <div className="detail-meta">
                    {show.year && <span>{show.year}</span>}
                    {show.seasons !== undefined && show.seasons !== '' && (
                      <span>{show.seasons} season{Number(show.seasons) === 1 ? '' : 's'}</span>
                    )}
                    {tmdbDetails?.number_of_episodes != null && (
                      <span>{tmdbDetails.number_of_episodes} episodes</span>
                    )}
                  </div>
                )}
                <div className="detail-rating-row">
                  {show.rating > 0 && (
                    <div className="detail-user-rating">
                      {[...Array(5)].map((_, i) => (
                        <Star key={i} size={20} filled={i < show.rating} />
                      ))}
                    </div>
                  )}
                  {(show.imdbRating != null && show.imdbRating > 0) && (
                    <span style={{ fontSize: '0.875rem', color: 'var(--text-muted)' }}>
                      TMDB {Number(show.imdbRating).toFixed(1)}/10
                    </span>
                  )}
                  <span className={`status-badge ${statusConfig[show.status]?.className}`}>
                    {statusConfig[show.status]?.label}
                  </span>
                </div>
                {loadingDetails ? (
                  <p className="detail-overview" style={{ color: 'var(--text-muted)' }}>Loading description…</p>
                ) : overview ? (
                  <p className="detail-overview">{overview}</p>
                ) : null}
                {show.notes && overview !== show.notes && (
                  <p className="detail-notes">Your notes: {show.notes}</p>
                )}
                {cast.length > 0 && (
                  <>
                    <div className="detail-cast-heading">Cast</div>
                    <div className="detail-cast-list">
                      {cast.map((c, i) => (
                        <div key={c.id ?? i} className="detail-cast-item">
                          <span className="name">{c.name}</span>
                          {c.character && (
                            <span className="character">· {c.character}</span>
                          )}
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>
            </div>
            <div className="detail-actions">
              <button type="button" className="btn-secondary" onClick={onClose}>Close</button>
              <button type="button" className="btn-secondary" onClick={() => onDelete(show.id)} style={{ color: '#f85149' }}>
                Delete
              </button>
              <button type="button" className="btn-primary" onClick={onEdit}>Edit</button>
            </div>
          </div>
        </div>
      );
    };

    // ============================================
    // FORM MODAL
    // ============================================

    const FormModal = ({ show, onSave, onClose, onDelete }) => {
      const [tmdbQuery, setTmdbQuery] = useState('');
      const [tmdbResults, setTmdbResults] = useState([]);
      const [isSearching, setIsSearching] = useState(false);
      const [isLoadingDetails, setIsLoadingDetails] = useState(false);

      const [formData, setFormData] = useState({
        title: show?.title || '',
        year: show?.year || '',
        status: show?.status || 'planToWatch',
        rating: show?.rating || 0,
        notes: show?.notes || '',
        posterUrl: show?.posterUrl || '',
        tmdbId: show?.tmdbId || null,
        seasons: typeof show?.seasons === 'number' ? show.seasons : (show?.seasons || ''),
        imdbRating: typeof show?.imdbRating === 'number' ? show.imdbRating : 0
      });

      const searchTimeout = useRef(null);

      useEffect(() => {
        if (tmdbQuery.length <= 2) {
          setTmdbResults([]);
          return;
        }
        if (searchTimeout.current) clearTimeout(searchTimeout.current);
        searchTimeout.current = setTimeout(async () => {
          setIsSearching(true);
          const results = await searchTMDB(tmdbQuery);
          setTmdbResults(results);
          setIsSearching(false);
        }, 500);
        return () => {
          if (searchTimeout.current) clearTimeout(searchTimeout.current);
        };
      }, [tmdbQuery]);

      const selectTMDBShow = async (result) => {
        setTmdbResults([]);
        setTmdbQuery('');
        setIsLoadingDetails(true);
        try {
          const details = await fetchTMDBDetails(result.id);
          const numSeasons = details?.number_of_seasons != null ? details.number_of_seasons : '';
          const voteAvg = details?.vote_average != null ? Number(details.vote_average) : 0;
          setFormData(prev => ({
            ...prev,
            title: result.name,
            year: result.first_air_date?.substring(0, 4) || '',
            posterUrl: result.poster_path ? `${TMDB_IMAGE_BASE}${result.poster_path}` : '',
            tmdbId: result.id,
            seasons: numSeasons,
            imdbRating: voteAvg
          }));
        } catch (e) {
          setFormData(prev => ({
            ...prev,
            title: result.name,
            year: result.first_air_date?.substring(0, 4) || '',
            posterUrl: result.poster_path ? `${TMDB_IMAGE_BASE}${result.poster_path}` : '',
            tmdbId: result.id
          }));
        } finally {
          setIsLoadingDetails(false);
        }
      };

      const handleSubmit = (e) => {
        e.preventDefault();
        
        if (!formData.title.trim()) {
          alert('Please enter a show title');
          return;
        }

        onSave({
          ...formData,
          id: show?.id || null
        });
      };

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              {show ? 'Edit Show' : 'Add Show'}
            </div>

            <form onSubmit={handleSubmit}>
              <div className="form-group">
                <label className="form-label">
                  {show ? 'Link or update from TMDB' : 'Search TMDB'}
                </label>
                <input
                  type="text"
                  className="form-input"
                  placeholder={show ? 'Search to link this show (description, seasons, cast)' : 'Search for a TV show...'}
                  value={tmdbQuery}
                  onChange={(e) => setTmdbQuery(e.target.value)}
                />
                {(isSearching || isLoadingDetails) && (
                  <div style={{ marginTop: '12px', color: 'var(--text-secondary)', fontSize: '14px' }}>
                    {isSearching ? 'Searching...' : 'Loading show details (seasons, rating)...'}
                  </div>
                )}
                {tmdbResults.length > 0 && (
                  <div className="tmdb-results">
                    {tmdbResults.slice(0, 5).map(result => (
                      <div
                        key={result.id}
                        className="tmdb-result"
                        onClick={() => selectTMDBShow(result)}
                      >
                        <div className="tmdb-poster">
                          {result.poster_path && (
                            <img src={`${TMDB_IMAGE_BASE}${result.poster_path}`} alt={result.name} />
                          )}
                        </div>
                        <div className="tmdb-info">
                          <div className="tmdb-title">{result.name}</div>
                          <div className="tmdb-meta">
                            {result.first_air_date?.substring(0, 4)}
                            {result.overview && ` • ${result.overview.substring(0, 100)}...`}
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              <div className="form-group">
                <label className="form-label">Title *</label>
                <input
                  type="text"
                  className="form-input"
                  value={formData.title}
                  onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                  required
                />
              </div>

              <div className="form-group">
                <label className="form-label">Year</label>
                <input
                  type="text"
                  className="form-input"
                  placeholder="2024"
                  value={formData.year}
                  onChange={(e) => setFormData({ ...formData, year: e.target.value })}
                />
              </div>

              <div className="form-group">
                <label className="form-label">Seasons</label>
                <div style={{ display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
                  <input
                    type="number"
                    min="0"
                    className="form-input"
                    placeholder="1"
                    style={{ flex: '1', minWidth: '80px' }}
                    value={formData.seasons}
                    onChange={(e) => setFormData({ ...formData, seasons: e.target.value === '' ? '' : Number(e.target.value) })}
                  />
                  {show?.tmdbId && (
                    <button
                      type="button"
                      className="btn-secondary"
                      disabled={isLoadingDetails}
                      onClick={async () => {
                        setIsLoadingDetails(true);
                        try {
                          const details = await fetchTMDBDetails(show.tmdbId);
                          if (details) {
                            setFormData(prev => ({
                              ...prev,
                              seasons: details.number_of_seasons != null ? details.number_of_seasons : prev.seasons,
                              imdbRating: details.vote_average != null ? Number(details.vote_average) : prev.imdbRating
                            }));
                          }
                        } finally {
                          setIsLoadingDetails(false);
                        }
                      }}
                    >
                      {isLoadingDetails ? 'Loading...' : 'Refresh from TMDB'}
                    </button>
                  )}
                </div>
              </div>

              <div className="form-group">
                <label className="form-label">Status</label>
                <select
                  className="form-select"
                  value={formData.status}
                  onChange={(e) => setFormData({ ...formData, status: e.target.value })}
                >
                  {Object.entries(statusConfig).map(([key, config]) => (
                    <option key={key} value={key}>{config.label}</option>
                  ))}
                </select>
              </div>

              <div className="form-group">
                <label className="form-label">Rating</label>
                <div className="star-rating-input">
                  {[1, 2, 3, 4, 5].map((star) => (
                    <button
                      key={star}
                      type="button"
                      className="star-btn"
                      onClick={() => setFormData({ 
                        ...formData, 
                        rating: formData.rating === star ? 0 : star 
                      })}
                    >
                      <Star size={28} filled={star <= formData.rating} />
                    </button>
                  ))}
                </div>
              </div>

              <div className="form-group">
                <label className="form-label">Notes</label>
                <textarea
                  className="form-textarea"
                  placeholder="Your thoughts..."
                  value={formData.notes}
                  onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
                />
              </div>

              <div className="modal-actions">
                <button type="button" className="btn-secondary" onClick={onClose}>
                  Cancel
                </button>
                {show && onDelete && (
                  <button 
                    type="button" 
                    className="btn-secondary" 
                    onClick={async () => {
                      await onDelete(show.id);
                      onClose();
                    }}
                    style={{ color: '#ef4444' }}
                  >
                    Delete
                  </button>
                )}
                <button type="submit" className="btn-primary">
                  {show ? 'Save Changes' : 'Add Show'}
                </button>
              </div>
            </form>
          </div>
        </div>
      );
    };

    // Expose console helpers at script load so they're always available (same scope as auth, db, TMDB)
    window.refreshCompletedSeasonsFromTMDB = async function() {
      try {
        const user = auth?.currentUser;
        if (user) {
          const userRef = db.collection('users').doc(user.uid);
          const snap = await userRef.get();
          const data = snap.data() || {};
          const showsMap = data.shows || {};
          let updated = 0;
          for (const [id, show] of Object.entries(showsMap)) {
            if (show.status !== 'completed' || !show.tmdbId) continue;
            const details = await fetchTMDBDetails(show.tmdbId);
            if (details?.number_of_seasons == null) continue;
            showsMap[id] = { ...show, seasons: details.number_of_seasons, imdbRating: details.vote_average ?? show.imdbRating };
            updated++;
          }
          if (updated > 0) {
            await userRef.set({ shows: showsMap, lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
            console.log('Updated', updated, 'completed show(s). Refresh the page.');
          } else console.log('No completed shows with TMDB ID found.');
        } else {
          const list = loadGuestShows();
          let updated = 0;
          for (let i = 0; i < list.length; i++) {
            const show = list[i];
            if (show.status !== 'completed' || !show.tmdbId) continue;
            const details = await fetchTMDBDetails(show.tmdbId);
            if (details?.number_of_seasons == null) continue;
            list[i] = { ...show, seasons: details.number_of_seasons, imdbRating: details.vote_average ?? show.imdbRating };
            updated++;
          }
          if (updated > 0) { saveGuestShows(list); console.log('Updated', updated, 'completed show(s). Refresh the page.'); }
          else console.log('No completed shows with TMDB ID found.');
        }
      } catch (e) { console.warn(e.message); }
    };

    window.linkUnlinkedShowsToTMDB = async function() {
      const delay = (ms) => new Promise(r => setTimeout(r, ms));
      try {
        const user = auth?.currentUser;
        let showsMap = {};
        try {
          if (user) {
            const snap = await db.collection('users').doc(user.uid).get();
            showsMap = (snap.data() || {}).shows || {};
          } else {
            const list = loadGuestShows();
            showsMap = Object.fromEntries((list || []).map(s => [String(s.id), { ...s }]));
          }
        } catch (e) { console.warn('Could not load shows:', e.message); return; }
        const needLink = Object.entries(showsMap).filter(([, s]) => s && !s.tmdbId && (s.title || '').trim());
        if (needLink.length === 0) { console.log('All shows already have a TMDB link.'); return; }
        console.log('Linking', needLink.length, 'show(s)...');
        let linked = 0;
        for (const [id, show] of needLink) {
          try {
            const title = (show.title || '').trim();
            if (!title) continue;
            const results = await searchTMDB(show.year ? `${title} ${show.year}` : title);
            await delay(300);
            if (!results?.length) { console.log('Skip (no result):', title); continue; }
            const first = results[0];
            if (!first || first.id == null) continue;
            const details = await fetchTMDBDetails(first.id);
            await delay(300);
            showsMap[id] = {
              ...show,
              title: first.name || title,
              year: (first.first_air_date && first.first_air_date.substring(0, 4)) || show.year || '',
              posterUrl: first.poster_path ? `${TMDB_IMAGE_BASE}${first.poster_path}` : (show.posterUrl || ''),
              tmdbId: first.id,
              seasons: details?.number_of_seasons != null ? details.number_of_seasons : '',
              imdbRating: details?.vote_average != null ? Number(details.vote_average) : 0
            };
            linked++;
            console.log('Linked:', title, '→', first.name || first.id);
          } catch (err) { console.warn('Skip', show.title, err.message); }
        }
        if (linked === 0) { console.log('No shows updated.'); return; }
        try {
          if (user) {
            await db.collection('users').doc(user.uid).set(
              { shows: showsMap, lastUpdated: firebase.firestore.FieldValue.serverTimestamp() },
              { merge: true }
            );
          } else {
            const list = Object.keys(showsMap).sort((a, b) => Number(a) - Number(b)).map(k => ({ ...showsMap[k], id: k }));
            saveGuestShows(list);
          }
          console.log('Done. Updated', linked, 'show(s). Refresh the page.');
        } catch (e) { console.warn('Save failed:', e.message); }
      } catch (err) { console.warn('linkUnlinkedShowsToTMDB:', err.message); }
    };

    // Render app
    ReactDOM.render(<TVShowTracker />, document.getElementById('root'));
  </script>
</body>
</html>
